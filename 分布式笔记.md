### 分布式定义
> A distributed system is one in which components located at networked computers communicate and coordinate their actions only by passing messages 
> - Distributed Systems concepts and Design(Third Edition)


#### 两个重点
* 分布在网络计算机上
* 组件之间仅仅通过消息传递来通信并协调工作

#### 互联网就是一个分布式系统
对浏览器发出的请求背后是一个大型的分布式系统在为我们服务
整个系统中有的负责处理，有的负责存储，有的负责计算，
最终通过协同把我们的请求变成最后的结果返回给浏览器

#### 问什么使用分布式系统
* 升级单机处理能力的性价比越来越低
* 单机处理能力存在瓶颈
* 处于稳定性和可用性的考虑

##### 摩尔定律：
> 当价格不变时，每隔18个月，集成电路上可容纳的晶体管数目会增加一倍，性能也将提升一倍

##### 阿姆达尔定律（Amdahl's law）:
> S(N) = 1/ [(1-P) + P/N]

##### 对于线程不安全的容器或对象
> 一般使用加锁或者通过 Copy On Write 方式
> 读写比例很高时，采用读写锁而非互斥锁

map中的value整型使用不安全的HashMap代码
```
public class TestClass{
	private HashMap<String, Integer> map =
		new HashMap<>();
	public synchronized void add(String key){
		Integer value = map.get(key);
		if(value == null){
			map.put(key,1);
		}
		else{
			map.put(key, value + 1);
		}
	}
}
```

使用ConcurrentHashMap来代替HashMap
```
public class TestClass{
	private ConcurrentHashMap<String, Integer> map =
		new ConcurrentHashMap<>();
	public void add(String key){
		Integer value = map.get(key);
		if(value == null){
			map.put(key,1);
		}
		else{
			map.put(key, value + 1);
		}
	}
}
```

#### 协同的多线程
> A,B 两个线程，B线程需要等到某个状态发生之后才能继续自己的工作，而这个状态改变或者时间产生和A线程相关。

#### 多进程模式
> 单线程->多线程->单机多进程->多机多进程

### Reactor模式
#### 多线程处理方式
> 一个人来就餐，一个服务员去服务，然后客人会看菜单，点菜。 服务员将菜单给后厨。
二个人来就餐，二个服务员去服务……
五个人来就餐，五个服务员去服务……

#### 线程池处理方式
> 越来越多的人对这家餐厅满意，客源又多了，同时来吃饭的人到了20人，老板高兴不起来了，再请服务员吧，占地方不说，还要开工钱，再请人就攒不到钱了。怎么办呢？老板想了想，10个服务员对付20个客人也是能对付过来的，服务员勤快点就好了，伺候完一个客人马上伺候另外一个，还是来得及的

#### Reactor处理方式
>老板后来发现，客人点菜比较慢，大部服务员都在等着客人点菜，其实干的活不是太多。老板能当老板当然有点不一样的地方，终于发现了一个新的方法，那就是：当客人点菜的时候，服务员就可以去招呼其他客人了，等客人点好了菜，直接招呼一声“服务员”，马上就有个服务员过去服务。嘿嘿，然后在老板有了这个新的方法之后，就进行了一次裁员，只留了一个服务员！这就是用单个线程来做多线程的事


#### I/O 模型
* 同步阻塞
>在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！
* 同步非阻塞IO
> 在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。
* 异步阻塞IO
> 此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！
* 异步非阻塞IO
> 在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。  

#### Reactor模式和Proactor模式对比
* Reactor 读取操作
> 1. 应用程序注册读就需事件和相关联的事件处理器
>2. 事件分离器等待事件的发生
>3. 当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器
>4. 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理
>写入操作类似于读取操作，只不过第一步注册的是写就绪事件。

* Proactor 读取操作
> 1. 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。
>2. 事件分离器等待读取操作完成事件
>3. 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。
>4. 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。
Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。

### 大型网站
> 访问量和数据量两者缺一不可

#### 架构演化
* 单机负载告警，数据库与应用分离
* 应用服务器负载告警，服务器走向集群
  * *引入负载均衡设备*
  *	*Session问题*
  	* Session Sticky
  	* Session Replication
  	* Session数据集中存储
  	* Cookie Based
* 数据读写压力变大，读写分离
	* 采用数据库作为读库
		* 数据复制问题
		* 应用对于数据源的选择问题
	* 搜索引擎是一个读库
	* 加速数据读取——缓存
		* 数据缓存——热缓存、更新缓存
		* 页面缓存——ESI
* 弥补RDBMS的不足，引入分布式存储系统
	* 分布式文件系统
	* 分布式Key-Value系统
	* 分布式数据库
* 读写分离后，数据又遇到瓶颈
	* 专库专用，数据垂直拆分
		* *应用需要配置多个数据源*
		* *分布式事务*
		* *去掉事务，关联查询需要改变实现*
	* 单机遇到瓶颈，数据水平拆分
	> 读写分离 解决的读压力大的问题
	> 垂直拆分 把不同的表拆到不同的数据库
	> 水平拆分 把同一个表拆到不同的数据库 
* 数据库之外，其他的挑战
	* 拆分应用
	* 服务化
* 消息中间件
> Message-oriented middleware(MOM) is software infrastructure focused on sending and receiving messages between distributed systems. -Wikipedia
面向消息的系统（消息中间件）是分布式系统中完成消息的发送和接收的基础软件

	优点：** *异步和解耦* **
 

### 构建Java中间件

维基百科的中间件定义
> In its most general sense, middleware is computer software that provides services to software applications beyond those available from the operating system. Middleware can be described as "software glue".Thus middleware is not obviously part of an operating system, not a database management system, and neither is it part of one software application. Middleware makes it easier for software developers to perform communication and input/output, so they can foucs on the specific purpose of their application.

#### 三个领域的中间件
* 过程调用和对象访问中间件：主要解决分布式环境下应用的互相访问问题，是信息服务化的基础
* 消息中间件：解决应用之间的消息传递、解耦、异步问题
* 数据访问中间件：主要解决应用访问数据库的共性问题的组件

### 服务框架
#### 服务化的好处
* 从结构上看，系统架构更为清晰，更立体
* 从稳定性上看，散落在多个应用系统中的代码也变为服务，提高代码的质量，提高稳定性
* 更加底层的资源统一由服务层管理，结构更加清晰，也更利于提高效率

> 服务框架应该是包含调用端逻辑又包含服务端逻辑的一个实现

##### 分布式的控制方式
> * 使用硬件负载均衡的请求调用
> * 使用LVS的请求调用 —— 透明代理
> * 使用名称服务的直连方式的请求调用
> * 采用规则服务器控制路由的请求直接调用
> * Master + Worker方式

##### 服务控制点基础属性
> interfaceName: 接口名称，通过接口来调用相应的方法
> version: 版本号，接口存在变化的可能性
> group: 分组，同一个接口的远程服务有很多的机器，把这些机器归组

##### 运行服务框架与应用和容器的关系
###### 两个问题
* 服务框架自身的部署问题
	* 把服务框架作为应用的一个依赖包与应用一起打包
	* 把服务框架作为容器的一部分
* 实现自己的服务框架所以俩的一些外部jar包与应用自身依赖的jar包之间的冲突问题

###### 负载均衡的实现
* 随机
* 轮询
* 权重
	* 动态权重--根据响应时间等参数来进行计算

###### 基于接口、方法、参数的路由

###### 多机房场景
* 在服务注册中心做一些工作
* 通过路由完成
	* 虚拟机房——把物理上的多个机房看做一个逻辑机房来处理路由规则
	
###### 流量控制
* 根据服务端自身的借口、方法做控制——为了使不同接口、方法之间的负载不相互影响
* 根据来源做控制——根据来源的不同级别进行不同的流控处理

###### 序列化的注意问题
* Java序列化或反序列化时自身的性能问题以及跨语言问题
* 序列化和反序列化的性能开销
* 序列化后的长度

######## 协议
> 用于通信的数据报文的自定义协议
> 远程调用本身的协议

###### 常见的异步远程通信方式
* Oneway单项的通知
* Callback
* Future 主动控制超时获取结果的方式
* 可靠异步，保证异步请求在远程被执行

###### 服务提供端的设计与实现
> 服务端的工作有两部分
> 一是对本地服务的注册管理
> 二是根据尽力啊的请求定位服务并执行

##### ** 整个服务框架作为一个产品，可以让集中在单机内部的调用变为远程的服务化 **
> 默认是随机选择服务，在有些场景下需要用权重。因此服务框架必须做到模块可配置化

##### 服务升级
* 接口不变，只是代码本身进行改善——灰度发布的方式验证
* 需要修改原有的接口
	* 在接口中增加方法
	* 在接口的某些方法修改调用的参数列表
		* 使用原来方法的代码都进行修改
		* 通过版本号来解决
		* 在设计上考虑参数的可以扩展性

#### 服务治理
> 服务治理：在系统采用服务框架后，为服务化保驾护航的功能集合

* 管理服务
* 查看服务

#### 企业服务总线
> 企业服务总线（ESB）
> 从面相服务体系架构（SOA）发展过来，对多样体系中的服务调用者和服务提供者的解耦。

差异
* 服务框架是一个点对点的模型，ESB是一个总线式的模型
* 服务宽假基本是面对同构的系统，不考虑整合的需求，而ESB更多考虑不同厂商提供服务的整合

### 数据访问层

数据库减压的思路
* 优化应用
* 降低对数据库的压力——如引入缓存、加搜索引擎
* 把数据库的数据和访问分到多台数据库上，分开支持

垂直拆分的影响
* 单机的ACID被打破，需要修改单机事务，引入分布式事务
* Join操作变得困难
* 靠外键去约束的场景受影响

水平拆分的影响
* ACID的影响
* Join操作的影响
* 外键约束的影响 
* 依赖单库的自增序列生成唯一ID受影响
* 针对单个逻辑意义上的表的查询受影响，需要跨库

	*例如原来的一些存储过程、触发器等也需要改写*
	
####　分布式事务

##### 分布式事务模型与规范
X/Open DTP模型
> X/Open DTP（X/Open Distributed Transaction Processing Reference Model）
* Application Program（AP）
* Resource Manager（RM）
* Transaction Manager（TM）

DTP
* 事务：一个事务是一个完成的工作单元，由多个独立的计算任务组成，在逻辑上是原子的
* 全局事务：一次性操作多个资源管理器的事务就是全局事务
* 分支事务：在全局事务中，每一个资源管理器都有自己独立的任务
* 控制线程：用来表示一个工作线程，主要是关联AP、TM和RM三者的线程，也就是事务上下文环境

DTP模型
* AP与RM之间，可以使用RM自身提供的native API进行交互
* AP与TM之间，使用TX接口，也是由X/Open所规范的。用于对事务进行控制，包括启动事务、提交事务和回滚事务
* TM与RM之间，通过XA接口进行交互。TM管理到RM的连接，并实现两阶段提交

两阶段提交（2PC，Two Phase Commitment Protocol）
> 在准备阶段一个资源失败，那么第二阶段的处理就是回滚所有资源

##### 大型网站一致性的理论基础——CAP/BASE
CAP理论
> Consistency： all nodes see the same data at the same time
> Availability: a guarantee that every request receives a response about whether it was successful or failed 
> Partition-Tolerance: the system continues to operate despite arbitrary message loss or failure of part of the system

系统设计和权衡
* CA 放弃分区容忍性，加强一致性和可用性——单机数据库
* AP 放弃一致性，追求分区容忍性及可用性——NoSQL
* CP 放弃可用性，追求一致性和分区容忍性

BASE模型
* Basically Available：基本可用，运行分区失败
* Soft state：软状态，接收一段时间的状态不同步
* Eventually consistent：最终一致，保证最终数据的一致




