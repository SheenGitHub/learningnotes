# 介绍 #
编译器就是一个程序，它可以阅读已某一种语言(源语言)编写的程序，并把该程序翻译成为一个等价的、用另一种语言（目标语言）编写的程序。

解释器是另一种语言处理器。它并不通过翻译的方式生成目标程序。从用户的角度看，解释器直接利用用户提供的输入执行源程序中指定的操作。

## 编译器的结构 ##
编译器把源程序映射为语义上等价的目标代码，映射过程分成两部分：分析部分(前端)和综合部分(后端)

分析：把源程序分解成多个组成要素，并在这些要素上加上语法结构。符号表和中间表示形式一起传送给综合部分。

综合：根据中间表示和符号表的信息来构造用户期待的目标程序。

![4216.png](http://ww1.sinaimg.cn/large/48ceb85dly1gdry4av2cjj20eu0evjt6.jpg)

### 词法分析 ###
lexical analysis/scannning

读入组成源程序的字符流，将它们组织成有意义的词素(lexeme)的序列，对于每个词素，词法分析器产生一个词法单元<token-name, attribute-value>

### 语法分析 ###
syntax analysis/parsing

语法分析器使用词法分析器生成的各个词法单元的第一个分量来创建树形的中间表示（syntax tree）
### 语义分析 ###
semantic analysis

语义分析器使用语法树和符号表中的信息来检查源程序是否和语言定义的语法一直，同时也手机类型信息，进行类型检查(type checking)和自动类型转换(coercion)

### 中间代码生成 ###
语法树是一种中间表示形式

### 代码优化 ###

### 代码生成 ###
代码生成一个至关重要的方面是合理分配寄存器以存放变量的值

#### 计算机体系结构的优化 ####
几乎所有的高性能系统都利用了两种技术:并行(parallelism)和内存层次结构(memory hierarchy)。

#### 环境与状态 ####
1. 环境是一个从名字到存储位置的映射。因为变量就是指内存环境。
1. 状态时从一个内存位置到它们值的映射

**环境与状态的映射**

1. 名字到位置的静态绑定与动态绑定:大部分是动态，全局变量是静态确定
1. 从位置到值的静态绑定与动态绑定：大部分是动态，静态常量和宏定义是静态

#### 静态作用域和动态作用域类比 ####
静态规则让我们寻找的声明位于最内层、包含变量使用位置的单元(块)中；而动态规则则让我们寻找的声明位于最内层、包含了变量使用时间的单元(过程调用)

# 语法制导翻译 #
syntaxt-directed translation

分析阶段的工作是围绕编译语言的“语法”展开的。一个程序设计语言的语法(syntax)描述了该语言的程序的正确行使，而该语言的语义(sematic)则定义了程序的含义，即每个程序在运行时做什么事情。

#### 一个编译器前端的模型 ####

![3247.png](http://ww1.sinaimg.cn/large/48ceb85dly1gdt1mhlgyaj20e303ct90.jpg)

## 语法定义 ##
**上下文无关文法**

文法自然地描述了大多数程序设计语言构造的层次化语法结构，形如Java的if-else

**if** (expression) statement **else** statement

产生式(production) stmt-> **if** (expr) stmt **else** stmt

**if**和括号这样的词法单元称为终结符(terminal),像expr和stmt这样的变量表示终结符号的序列，称为非终结符(nonterminal)

### 文法定义 ###
上下文无关文法(context-free grammar)由四个元素组成：

1. 一个终结符号集合，有时也称为“词法单元”。终结符号是该文法所定义的语言的基本符号的集合。
1. 一个非终结符号集合，有时也称为“语法变量”。每个非终结符号表示一个终结符号串的集合。
1. 一个产生式，其中每个产生式包括一个产生式头或左部的非终结符号，一个箭头，和一个称为产生式体或右部的由终结符号及非终结符号组成的序列。
1. 指定一个非终结符号为开始符号

> 在编译器中，词法分析器读入源程序的字符序列，将它们组织成为具有词法含义的词素，生成并输出代表这些词素的词法单元序列。词法单元由两个部分组成：名字和属性值。词法单元的名字是语法分析器进行语法分析时使用的抽象符号。词法单元名字通常称为终结符号。如果词法单元具有属性值，那么这个值就是一个指向符号表的指针，符号表中包含了该词法单元的附加信息。

#### 例子文法 ####

*list*->*list* + *digit*

*list*->*list* - *digit*

*list*->*digit*

*digit*->0|1|2|3|4|5|6|7|8|9|

以非终结符list为头部的三个产生式可以等价组合为：

*list*->*list* + *list* | *list* - *digit* | *digit*

该文法的终结符号包括如下字符：+ - 0 1 2 3 4 5 6 7 8 9 0  

该文法的终结符号是*list* 和 *digit*，因为list的产生式首先被列出，所以*list*是此文法的开始符号

如果某个非终结符号是某个产生式的头部，称该产生式是该终结符号的产生式。一个终结符号串是由0个或多个终结符号组成的序列。零个终结符号组成的串成为空串。

可以从**开始符号推导得到的所有终结符号串的集合**称为该文法定义的语言(language)

函数的调用列表
	
	     call -> id ( optparams )
	optparams -> params | ε
	params    -> params, param | param

> **语法分析的任务是：接收一个终结符号作为输入，找出从文法的开始符号推导出这个串的方法。如果不能从文法的开始符号推导得到该终结符号串，则报告该中介符号串中包含的语法错误。**

### 语法分析树 ###
词法分析树用图形方式展示了从文法的开始符号推导出相应语言中的符号串的过程。如果非终结符号A有一个产生式A->XYZ，那么在语法分析树中就可能有一个标号为A的内部结点，该结点有三个子节点，从左向右的标号分别为X,Y,Z:

	   A
	 / | \
	X  Y  Z

给定一个上下文无关文法，该文法的语法分析树(parse tree)是具有以下性质的树：

1. 根节点的标号为文法的开始符号。
1. 每个叶子结点的标号为一个终结符号或ε。
1. 每个内部结点的标号为一个非终结符号。
1. 如果非终结符号A是某个内部结点的标号，并且它的子结点的标号从左至右分别为X<sub>1</sub>,X<sub>2</sub>,X<sub>3</sub>,...,X<sub>n</sub>,那么必然存在一个产生式A-> X<sub>1</sub>X<sub>2</sub>X<sub>3</sub>...X<sub>n</sub>,其中X<sub>1</sub>,X<sub>2</sub>,X<sub>3</sub>,...,X<sub>n</sub>既可以是终结符号，也可以是非终结符号。作为一个特殊情况，如果A->ε是一个产生式，那么一个标号为A的结点可以只有一个标号为ε的子结点

一个文法的语言的另一个定义是指任何能够由某课语法分析树生成的符号串的集合。为一个给定的终结符号串创建一课语法分析树的称为对该符号串进行**语法分析**
。

### 二义性 ###
ambiguous

一个文法可能有多棵语法分析树能够生成同一个给定的终结符号串。这样的文法具有二义性。要证明文法具有二义性，我们只需找到一个终结符号串，说明它是两棵以上语法分析树的结果。

### 运算符的结合性 ###
运算符'+'是左结合的，表示运算分量两侧都有'+'时，它属于其左边的运算符;运算符'='及其后裔'+=','-='是右结合的 a=b=c;

带有右结合运算符的串，比如a=b=c可以由以下文法产生

	right -> letter=right|letter
	letter -> a|b|...|z

### 运算符的优先级 ###
运算符结合性规则只能用于同一运算符的多次出现

算数表示的文法可根据表示运算符结合性和优先级的表格来构建。

优先级表：

- 左结合:+ -
- 左结合:* /

穿件两个非终结符expr和term，分别对应这两个优先级层次，并使用非终结符factor来生成表达式中的基本单元。表达式的基本单元是数位和带括号的表达式。

	factor -> digit|(expr)
	item -> item * factor | term / factor | term
	expr -> expr + term | expr - term| term

最终文法是 

	expr -> expr + term | expr - term | term
	term -> term * factor | term / factor | factor
	factor -> digit|(expr)